# О задаче данного скрипта:
# На ПФШ 116 раз промультиплицированы два модуля, каждый содержит 5 кружков разного диаметра.
# Самый маленький кружок в одном модуле совпадает с самым большим в другом модуле.
# Всего имеется 9 разных типов кружков, состоящих из разных шторок.
# Все кружки делаются с неким, предположительно общим, поворотом (10 градусов).
# Все кружки кроме двух самых больших разбиваются на две взаимоперпендикулярные части.
# Два самых больших кружка содержат квадратную середину, выделяемую отдельно.
# Каждая часть каждого кружка (всего 20 штук и ещё маркировка) записывается в отдельный dxf-файл формата LFP00, где 00 - порядковый номер (M для маркировки).
# Необходимо после оптимизации каждого файла по отдельности свести их в общий с наименьшим количеством поворотов и смен шторок.

# Данный скрипт считывает каждый из 21 файла, записывает каждую его часть, относящуюся к определённому углу в соответствующую ячейку стека
# После обработки файлов, весь стек суммируется и записывается в выходной файл.

STACK = {} # Стэк больше не имеет фиксированое количество углов. Туда записываются все углы, какие встречаются в файлах.
X = Y = H = W = ''

FILES = []
for i in range(1,21):
    FILES.append('LFP%02i.opt' % i)
    # Идёт перебор имён файлов с 20-ю слоями топологии ФШ.
FILES.append('LFPM.opt')
# Дополнительно был добавлен файл с маркировкой ФШ.
# В прошлый раз при добавлении маркировки вручную, pat-код не был сохранён в точности при переносе.
# В результате этого пострадали цифры '2' и '7'.

for name in FILES:
    F1 = open(name, 'r')
    string = F1.readline()
    while not '$' in string :
        
        X1 = string.find('X')
        Y1 = string.find('Y')
        H1 = string.find('H')
        W1 = string.find('W')
        A1 = string.find('A')
        A2 = string.find(';')
        
        if   Y1 > -1: X2 = Y1
        elif H1 > -1: X2 = H1
        elif W1 > -1: X2 = W1
        elif A1 > -1: X2 = A1
        else: X2 = A2

        if   H1 > -1: Y2 = H1
        elif W1 > -1: Y2 = W1
        elif A1 > -1: Y2 = A1
        else: Y2 = A2

        if   W1 > -1: H2 = W1
        elif A1 > -1: H2 = A1
        else: H2 = A2

        if   A1 > -1: W2 = A1
        else: W2 = A2

        if X1 > -1: X = string[X1:X2]
        if Y1 > -1: Y = string[Y1:Y2]
        if H1 > -1: H = string[H1:H2]
        if W1 > -1: W = string[W1:W2]

        if A1 > -1:
            A = string[A1:A2]
            string = X+Y+H+W+A+';\n'

        if not A in STACK:
            STACK[A]=''
            # Если угла не было в стэке, он добавляется с пустым полем
        STACK[A] += string
        string = F1.readline()
    F1.close()

F2 = open('result.opt', 'w')
for item in sorted(STACK):
    F2.write(STACK[item])
    # Считывание происходит не по конкретным углам, а по всему содержимому отсортированного стэка.
F2.write('$;\n')
F2.close()

print ('Done!')

# Результаты стандартной оптимизации
# ========================
# На 33304 элемента:
# пробег 68300.597 ед.,
# смена шторки 13101 раз,
# смена угла 11 раз.
# Вес файла 387 124 байт
# ========================

# Результаты интеллектуальной оптимизации
# ========================
# На 33304 элемента:
# пробег 61776.891 ед.,
# смена шторки 258 раз,
# смена угла 11 раз.
# Вес файла 437 954 байт
# ========================
